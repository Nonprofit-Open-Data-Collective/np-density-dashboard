if( winsorize > 1 | winsorize < 0 )
{ stop( "winsorize argument must be 0 < w < 1" ) }
# check that data is coming from either F990 or the F990EZ, but not both
if( (is.null(f.cash)==F | is.null(f.si)==F | is.null(f.pr)==F | is.null(f.ar)==F |
is.null(f.tfe)==F | is.null(f.dda)==F) & (is.null(ez.csi)==F | is.null(ez.toe)==F) )
{ stop( "Data fields must come from one of: i. F990 or ii. F990EZ, but not both. Ensure you have accurately passed the data field to the correct arguments." ) }
if ( (length( c(f.cash, f.si, f.pr, f.ar, f.tfe, f.dda) ) < 6)==T & (is.null(ez.csi)==T | is.null(ez.toe)==T) )
{ stop( "Missing at least one data field from the F990 data. Ensure you are passing the correct data field to the correct argument." ) }
if (length( c(ez.toe, ez.csi) ) < 2 & (is.null(f.cash)==T | is.null(f.si)==T | is.null(f.pr)==T | is.null(f.ar)==T |
is.null(f.tfe)==T | is.null(f.dda)==T) )
{ stop( "Missing at least one data field from the F990EZ data. Ensure you are passing the correct data field to the correct argument." ) }
# pass with F990 form
if( (is.null(f.cash)==F & is.null(f.si)==F & is.null(f.pr)==F & is.null(f.ar)==F &
is.null(f.tfe)==F & is.null(f.dda)==F) )
{
n <- df[[ f.cash ]] + df[[ f.si ]] + df[[ f.pr ]] + df[[f.ar]]
d <- ( df[[ f.tfe ]] + df[[ f.dda ]] ) / 365
}
# pass with 990-EZ
else if( (is.null(ez.csi)==F | is.null(ez.toe)==F) )
{
n <- df[[ ez.csi ]]
d <- ( df[[ ez.toe ]] ) / 365
}
# can't divide by zero
print( paste0( "Assets cannot be zero: ", sum(d==0), " cases have been replaced with NA." ) )
d[ d == 0 ] <- NA
doch <- n / d
top.p    <- 1 - (1-winsorize)/2
bottom.p <- 0 + (1-winsorize)/2
top      <- quantile( doch, top.p, na.rm=T )
bottom   <- quantile( doch, bottom.p, na.rm=T )
doch.w    <- doch
doch.w[ doch.w > top    ] <- top
doch.w[ doch.w < bottom ] <- bottom
doch.n <- scale( doch.w )
doch.p <- dplyr::ntile( doch, 100 )
DOCH <- data.frame( doch, doch.w, doch.n, doch.p )
print( summary( DOCH ) )
par( mfrow=c(2,2) )
plot( density(doch,   na.rm=T), main="Days of Operating Cash on Hand (DOCH)" )
plot( density(doch.w, na.rm=T), main="DOCH Winsorized" )
plot( density(doch.n, na.rm=T), main="DOCH Standardized as Z" )
plot( density(doch.p, na.rm=T), main="DOCH as Percentile" )
df.doch <- cbind( df, DOCH )
return( df.doch )
}
# zero in the denominator
x5[,c(1:10)]<-0
x6[,c(1:10)]<-0
# zero in the denominator
x5[c(1:10),]<-0
x6[c(1:10),]<-0
x1 <- rnorm(1000,100,30)
x2 <- rnorm(1000,200,30)
x3 <- rnorm(1000,200,30)
x4 <- rnorm(1000,200,30)
x5 <- rnorm(1000,200,30)
x6 <- rnorm(1000,200,30)
# zero in the denominator
x5[c(1:10)]<-0
x6[c(1:10)]<-0
dat<-data.frame(x1,x2,x3,x4,x5,x6)
get_doch(df=dat, f.cash='x1', f.si = 'x2',
f.pr='x3', f.ar='x4', ez.toe='x5',f.dda='x6')
get_doch(df=dat, f.cash='x1', f.si = 'x2',
f.pr='x3', f.ar='x4', f.tfe='x5',f.dda='x6')
# zero in the denominator
x5[c(1:10)]<-0
x6[c(1:10)]<-0
dat<-data.frame(x1,x2,x3,x4,x5,x6)
get_doch(df=dat, f.cash='x1', f.si = 'x2',
f.pr='x3', f.ar='x4', f.tfe='x5',f.dda='x6')
get_doch(df=dat, f.cash='x1', f.si = 'x2',
f.pr='x3', f.ar='x4', f.tfe='x5',f.dda='x6')
f.pr='x3', f.ar='x4', f.tfe='x5',f.dda='x6', winsorize=0.95 )
# winsorize at 0.025 and 0.975 percentiles instead of 0.01 and 0.99
d <- get_doch(df=dat, f.cash='x1', f.si = 'x2',
f.pr='x3', f.ar='x4', f.tfe='x5',f.dda='x6', winsorize=0.95 )
d
get_doch(df=dat, f.cash='x1', f.si = 'x2',
f.pr='x3', f.ar='x4', f.tfe='x5',f.dda='x6', winsorize=0.90 )
library(hei)
View(get_fped())
View(get_fped)
?get_fped
year='2005/2006'
day='first'
yearchoices <- c(fped0506 = "2005/2006", fped0708 = "2007/2008",
fped0910 = "2009/2010", fped1112 = "2011/2012", fped1314 = "2013/2014")
yearchoices
yearchoices <- c(fped0506 = "2005/2006", fped0708 = "2007/2008",
fped0910 = "2009/2010", fped1112 = "2011/2012", fped1314 = "2013/2014")
daychoices <- c(both = "both", day1 = "first", day2 = "second")
try(if (!year %in% yearchoices)
stop("must use valid year choice, see ?get_fped for valid choices",
call. = FALSE))
try(if (!day %in% daychoices)
stop("must use valid day choice, see ?get_fped for valid choices",
call. = FALSE))
fped <- paste0(names(which(yearchoices == year)), "_", names(which(daychoices ==
day)))
fped
eval(parse(text = fped))
load("/Users/Chris/Downloads/sysdata.rda")
eval(parse(text = fped))
10/3505
library( tidyverse )
?GENDER
?gender
View(gender::gender())
View(gender::gender)
x1 <- rnorm( 1000,100,30 )
x2 <- rnorm( 1000,200,30 )
x2[ c(15,300,600) ] <- 0
dat <- data.frame( x1, x2 )
specify own column names
x1 <- rnorm( 1000,100,30 )
x2 <- rnorm( 1000,200,30 )
x2[ c(15,300,600) ] <- 0
dat <- data.frame( x1, x2 )
x1 <- rnorm( 1000,100,30 )
x2 <- rnorm( 1000,200,30 )
x2[ c(15,300,600) ] <- 0
x1 <- rnorm( 1000,100,30 )
x2 <- rnorm( 1000,200,30 )
x2[ c(15,300,600) ] <- 0
x3 <- rnorm( 1000,100,30 )
x4 <- rnorm( 1000,200,30 )
x4[ c(15,300,600) ] <- 0
dat <- data.frame( x1, x2 x3, x4)
dat <- data.frame( x1, x2 x3, x4)
dat <- data.frame( x1, x2,x3, x4)
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x4" )
#' # neither numerator nor denominator specified
#' d <- get_ssr( df = dat, prog.serv.rev = NULL, total.expense = NULL )
#'
#' # column names vector not of correct length
#' d <- get_ssr( df = dat, prog.serv.rev = c('a','b','c'), total.expense = 'a' )
#'
#' # column names vector not of correct length
#' d <- get_ssr( df = dat, prog.serv.rev = 'a', total.expense = c( 'a', 'b', 'c' ) )
#'
#' @export
get_ssr <- function( df, prog.serv.rev = c( 'F9_08_REV_PROG_TOT_TOT', 'F9_01_REV_PROG_TOT_CY' ),
total.expense = c( 'F9_09_EXP_TOT_TOT', 'F9_01_EXP_TOT_CY' ),
winsorize=0.98 )
{
# quoted/unquoted arguments
if( !is.null( substitute( prog.serv.rev ) ) )   prog.serv.rev   <- rm_quote( deparse( substitute( prog.serv.rev ) ) )
if( !is.null( substitute( total.expense ) ) )   total.expense   <- rm_quote( deparse( substitute( total.expense ) ) )
# function checks
if( winsorize > 1 | winsorize < 0 )
{ stop( "winsorize argument must be 0 < w < 1" ) }
if( is.null( prog.serv.rev )==T & is.null( total.expense )==F )
{ stop( "The numerator has been incorrectly specified. Ensure you are passing the correct data field to the correct argument." ) }
if( is.null( prog.serv.rev )==F & is.null( total.expense )==T )
{ stop( "The denominator has been incorrectly specified. Ensure you are passing the correct data field to the correct argument." ) }
if( is.null( prog.serv.rev )==T & is.null( total.expense )==T )
{ stop( "The argument fields are empty. Please supply column names for each argument or execute the function with default inputs." ) }
if( length( prog.serv.rev ) > 2 | length( prog.serv.rev ) < 1 )
{ stop( "`prog.serv.rev` must be a single quoted or unquoted string or a vector with a minimum length of one and maximum length of two." ) }
if( length( total.expense ) > 2 | length( total.expense ) < 1 )
{ stop( "`total.expense` must be a single quoted or unquoted string or a vector with a minimum length of one and maximum length of two." ) }
# copy data
dat <- df
if ( length( prog.serv.rev )==2 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ is.na( dat[ prog.serv.rev[2] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ is.na( dat[ prog.serv.rev[1] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
# create a column that concatenates two denominator variables into single column
dat[ is.na( dat[ total.expense[2] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ is.na( dat[ total.expense[1] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==2 & length( total.expense )==1 ) {
# create a column that concatenates two denominator variables into single column
dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ total.expense ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ which( is.na( dat[ total.expense[2] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ which( is.na( dat[ total.expense[1] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ prog.serv.rev ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==1 ) {
p <- dat[[ prog.serv.rev ]]
e <- dat[[ total.expense ]]
}
# can't divide by zero
print( paste0( "Total expenses cannot be equal to zero: ", sum( e==0 ), " cases have been replaced with NA." ) )
e[ e == 0 ] <- NA
ssr <- p / e
top.p    <- 1 - (1-winsorize)/2
bottom.p <- 0 + (1-winsorize)/2
top      <- quantile( ssr, top.p, na.rm=T )
bottom   <- quantile( ssr, bottom.p, na.rm=T )
ssr.w    <- ssr
ssr.w[ ssr.w > top    ] <- top
ssr.w[ ssr.w < bottom ] <- bottom
ssr.n <- scale( ssr.w )
ssr.p <- dplyr::ntile( ssr, 100 )
SSR <- data.frame( ssr, ssr.w, ssr.n, ssr.p )
print( summary( SSR ) )
par( mfrow=c(2,2) )
plot( density(ssr,   na.rm=T), main="Self Sufficiency Ratio (SSR)" )
plot( density(ssr.w, na.rm=T), main="SSR Winsorized" )
plot( density(ssr.n, na.rm=T), main="SSR Standardized as Z" )
plot( density(ssr.p, na.rm=T), main="SSR as Percentile" )
df.ssr <- data.frame( cbind( df, SSR ) )
return( df.ssr )
}
d <- get_ssr( df = dat, prog.serv.rev = c( "x1", "x2" ), total.expense = c( "x4", "x5" )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1", "x2" ), total.expense = c( "x3", "x4" ) )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1", "x2" ), total.expense = c( "x3", "x4" ) )
# remove double quotes
rm_quote <- function( x ) {
gsub( "\"", "", x )
}
d <- get_ssr( df = dat, prog.serv.rev = c( "x1", "x2" ), total.expense = c( "x3", "x4" ) )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1" ), total.expense = c( "x3" ) )
dat
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1" ), total.expense = c( "x2" ) )
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
d <- get_ssr( df = dat, prog.serv.rev = c("x1"), total.expense = c("x2") )
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1" ), total.expense = c( "x2" ) )
df = dat; prog.serv.rev = c( "x1" ); total.expense = c( "x2" )
# quoted/unquoted arguments
if( !is.null( substitute( prog.serv.rev ) ) )   prog.serv.rev   <- rm_quote( deparse( substitute( prog.serv.rev ) ) )
if( !is.null( substitute( total.expense ) ) )   total.expense   <- rm_quote( deparse( substitute( total.expense ) ) )
# function checks
if( winsorize > 1 | winsorize < 0 )
{ stop( "winsorize argument must be 0 < w < 1" ) }
# copy data
dat <- df
if ( length( prog.serv.rev )==2 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ is.na( dat[ prog.serv.rev[2] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ is.na( dat[ prog.serv.rev[1] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
# create a column that concatenates two denominator variables into single column
dat[ is.na( dat[ total.expense[2] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ is.na( dat[ total.expense[1] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==2 & length( total.expense )==1 ) {
# create a column that concatenates two denominator variables into single column
dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ total.expense ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ which( is.na( dat[ total.expense[2] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ which( is.na( dat[ total.expense[1] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ prog.serv.rev ]]
e <- dat[[ 'e' ]]
}
p <- dat[[ prog.serv.rev ]]
prog.serv.rev
e <- dat[[ total.expense ]]
#' # neither numerator nor denominator specified
#' d <- get_ssr( df = dat, prog.serv.rev = NULL, total.expense = NULL )
#'
#' # column names vector not of correct length
#' d <- get_ssr( df = dat, prog.serv.rev = c('a','b','c'), total.expense = 'a' )
#'
#' # column names vector not of correct length
#' d <- get_ssr( df = dat, prog.serv.rev = 'a', total.expense = c( 'a', 'b', 'c' ) )
#'
#' @export
get_ssr <- function( df, prog.serv.rev = c( 'F9_08_REV_PROG_TOT_TOT', 'F9_01_REV_PROG_TOT_CY' ),
total.expense = c( 'F9_09_EXP_TOT_TOT', 'F9_01_EXP_TOT_CY' ),
winsorize=0.98 )
{
# quoted/unquoted arguments
if( !is.null( substitute( prog.serv.rev ) ) )   prog.serv.rev   <- rm_quote( deparse( substitute( prog.serv.rev ) ) )
if( !is.null( substitute( total.expense ) ) )   total.expense   <- rm_quote( deparse( substitute( total.expense ) ) )
# function checks
if( winsorize > 1 | winsorize < 0 )
{ stop( "winsorize argument must be 0 < w < 1" ) }
if( is.null( prog.serv.rev )==T & is.null( total.expense )==F )
{ stop( "The numerator has been incorrectly specified. Ensure you are passing the correct data field to the correct argument." ) }
if( is.null( prog.serv.rev )==F & is.null( total.expense )==T )
{ stop( "The denominator has been incorrectly specified. Ensure you are passing the correct data field to the correct argument." ) }
if( is.null( prog.serv.rev )==T & is.null( total.expense )==T )
{ stop( "The argument fields are empty. Please supply column names for each argument or execute the function with default inputs." ) }
if( length( prog.serv.rev ) > 2 | length( prog.serv.rev ) < 1 )
{ stop( "`prog.serv.rev` must be a single quoted or unquoted string or a vector with a minimum length of one and maximum length of two." ) }
if( length( total.expense ) > 2 | length( total.expense ) < 1 )
{ stop( "`total.expense` must be a single quoted or unquoted string or a vector with a minimum length of one and maximum length of two." ) }
# copy data
dat <- df
if ( length( prog.serv.rev )==2 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ is.na( dat[ prog.serv.rev[2] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ is.na( dat[ prog.serv.rev[1] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
# create a column that concatenates two denominator variables into single column
dat[ is.na( dat[ total.expense[2] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ is.na( dat[ total.expense[1] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==2 & length( total.expense )==1 ) {
# create a column that concatenates two denominator variables into single column
dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ total.expense ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ which( is.na( dat[ total.expense[2] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ which( is.na( dat[ total.expense[1] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ prog.serv.rev ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==1 ) {
p <- dat[[ prog.serv.rev[1] ]]
e <- dat[[ total.expense[1] ]]
}
# can't divide by zero
print( paste0( "Total expenses cannot be equal to zero: ", sum( e==0 ), " cases have been replaced with NA." ) )
e[ e == 0 ] <- NA
ssr <- p / e
top.p    <- 1 - (1-winsorize)/2
bottom.p <- 0 + (1-winsorize)/2
top      <- quantile( ssr, top.p, na.rm=T )
bottom   <- quantile( ssr, bottom.p, na.rm=T )
ssr.w    <- ssr
ssr.w[ ssr.w > top    ] <- top
ssr.w[ ssr.w < bottom ] <- bottom
ssr.n <- scale( ssr.w )
ssr.p <- dplyr::ntile( ssr, 100 )
SSR <- data.frame( ssr, ssr.w, ssr.n, ssr.p )
print( summary( SSR ) )
par( mfrow=c(2,2) )
plot( density(ssr,   na.rm=T), main="Self Sufficiency Ratio (SSR)" )
plot( density(ssr.w, na.rm=T), main="SSR Winsorized" )
plot( density(ssr.n, na.rm=T), main="SSR Standardized as Z" )
plot( density(ssr.p, na.rm=T), main="SSR as Percentile" )
df.ssr <- data.frame( cbind( df, SSR ) )
return( df.ssr )
}
d <- get_ssr( df = dat; prog.serv.rev = c( "x1" ); total.expense = c( "x2" ) )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1" ), total.expense = c( "x2" ) )
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
x3 <- rnorm( 1000,100,30 )
x4 <- rnorm( 1000,200,30 )
x3[ seq( from = 1, to = 1000, 50 ) ] <- NA
x4[ seq( from = 1, to = 1000, 71 ) ] <- NA
dat_01 <- data.frame( x1, x2, x3, x4 )
colnames( dat_01 ) <- c( 'F9_08_REV_PROG_TOT_TOT', 'F9_09_EXP_TOT_TOT',
'F9_01_REV_PROG_TOT_CY', 'F9_01_EXP_TOT_CY')
run only with 990 variable names
d <- get_ssr( dat_01, prog.serv.rev = "F9_08_REV_PROG_TOT_TOT", total.expense = "F9_09_EXP_TOT_TOT" )
#run only with 990-EZ variable names
d <- get_ssr( dat_01, prog.serv.rev = "F9_01_REV_PROG_TOT_CY", total.expense = "F9_01_EXP_TOT_CY" )
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense ="x2", winsorize=0.95 )
d <- get_ssr( dat_01, winsorize = 0.95 )
colnames( dat_01 )
d <- get_ssr( dat_01, winsorize = 0.95 ) # not working
df = dat; prog.serv.rev = c( "x1" ); total.expense = c( "x2" )
length(total.expense)
length(prog.serv.rev)
df = dat; prog.serv.rev = "x1"; total.expense = "x2"
length(prog.serv.rev)
length(prog.serv.rev)
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
d <- get_ssr( df = dat, prog.serv.rev = c( "x1" ), total.expense = c( "x2" ) )
d <- get_ssr( df = dat, prog.serv.rev = "x1" , total.expense = c( "x2" ) )
d <- get_ssr( df = dat, prog.serv.rev = "x1" , total.expense = "x2"  )
x1 <- rnorm( 1000,100,30 )
x2 <- rnorm( 1000,200,30 )
x2[ c(15,300,600) ] <- 0
x3 <- rnorm( 1000,100,30 )
x4 <- rnorm( 1000,200,30 )
x4[ c(15,300,600) ] <- 0
d <- get_ssr( df = dat, prog.serv.rev = "x3", total.expense = "x4" )
d <- get_ssr( df = dat, prog.serv.rev = "x1", total.expense = "x2" )
x3 <- rnorm( 1000,100,30 )
x4 <- rnorm( 1000,200,30 )
x3[ seq( from = 1, to = 1000, 50 ) ] <- NA
x4[ seq( from = 1, to = 1000, 71 ) ] <- NA
dat_01 <- data.frame( x1, x2, x3, x4 )
colnames( dat_01 ) <- c( 'F9_08_REV_PROG_TOT_TOT', 'F9_09_EXP_TOT_TOT',
'F9_01_REV_PROG_TOT_CY', 'F9_01_EXP_TOT_CY')
d <- get_ssr( dat_01, prog.serv.rev = "F9_08_REV_PROG_TOT_TOT", total.expense = "F9_09_EXP_TOT_TOT" )
#run only with 990-EZ variable names
d <- get_ssr( dat_01, prog.serv.rev = "F9_01_REV_PROG_TOT_CY", total.expense = "F9_01_EXP_TOT_CY" )
d <- get_ssr( dat_01) # not working
d <- get_ssr( df = dat, prog.serv.rev = x1 , total.expense = c( x2 ) )
d <- get_ssr( df = dat, prog.serv.rev = x1, total.expense = x2 )
d <- get_ssr( df = dat, prog.serv.rev = 'x1', total.expense = 'x2' )
#' # neither numerator nor denominator specified
#' d <- get_ssr( df = dat, prog.serv.rev = NULL, total.expense = NULL )
#'
#' # column names vector not of correct length
#' d <- get_ssr( df = dat, prog.serv.rev = c('a','b','c'), total.expense = 'a' )
#'
#' # column names vector not of correct length
#' d <- get_ssr( df = dat, prog.serv.rev = 'a', total.expense = c( 'a', 'b', 'c' ) )
#'
#' @export
get_ssr <- function( df, prog.serv.rev = c( 'F9_08_REV_PROG_TOT_TOT', 'F9_01_REV_PROG_TOT_CY' ),
total.expense = c( 'F9_09_EXP_TOT_TOT', 'F9_01_EXP_TOT_CY' ),
winsorize=0.98 )
{
# function checks
if( winsorize > 1 | winsorize < 0 )
{ stop( "winsorize argument must be 0 < w < 1" ) }
if( is.null( prog.serv.rev )==T & is.null( total.expense )==F )
{ stop( "The numerator has been incorrectly specified. Ensure you are passing the correct data field to the correct argument." ) }
if( is.null( prog.serv.rev )==F & is.null( total.expense )==T )
{ stop( "The denominator has been incorrectly specified. Ensure you are passing the correct data field to the correct argument." ) }
if( is.null( prog.serv.rev )==T & is.null( total.expense )==T )
{ stop( "The argument fields are empty. Please supply column names for each argument or execute the function with default inputs." ) }
if( length( prog.serv.rev ) > 2 | length( prog.serv.rev ) < 1 )
{ stop( "`prog.serv.rev` must be a single quoted or unquoted string or a vector with a minimum length of one and maximum length of two." ) }
if( length( total.expense ) > 2 | length( total.expense ) < 1 )
{ stop( "`total.expense` must be a single quoted or unquoted string or a vector with a minimum length of one and maximum length of two." ) }
# copy data
dat <- df
if ( length( prog.serv.rev )==2 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ is.na( dat[ prog.serv.rev[2] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ is.na( dat[ prog.serv.rev[1] ] )==F, 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
# create a column that concatenates two denominator variables into single column
dat[ is.na( dat[ total.expense[2] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ is.na( dat[ total.expense[1] ] )==F, 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==2 & length( total.expense )==1 ) {
# create a column that concatenates two denominator variables into single column
dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[2] ] )==F ), prog.serv.rev[2] ]
dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), 'p' ] <- dat[ which( is.na( dat[ prog.serv.rev[1] ] )==F ), prog.serv.rev[1] ]
p <- dat[[ 'p' ]]
e <- dat[[ total.expense ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==2 ) {
# create a column that concatenates two numerator variables into single column
dat[ which( is.na( dat[ total.expense[2] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[2] ] )==F ), total.expense[2] ]
dat[ which( is.na( dat[ total.expense[1] ] )==F ), 'e' ] <- dat[ which( is.na( dat[ total.expense[1] ] )==F ), total.expense[1] ]
p <- dat[[ prog.serv.rev ]]
e <- dat[[ 'e' ]]
}
else if ( length( prog.serv.rev )==1 & length( total.expense )==1 ) {
p <- dat[[ prog.serv.rev ]]
e <- dat[[ total.expense ]]
}
# can't divide by zero
print( paste0( "Total expenses cannot be equal to zero: ", sum( e==0 ), " cases have been replaced with NA." ) )
e[ e == 0 ] <- NA
ssr <- p / e
top.p    <- 1 - (1-winsorize)/2
bottom.p <- 0 + (1-winsorize)/2
top      <- quantile( ssr, top.p, na.rm=T )
bottom   <- quantile( ssr, bottom.p, na.rm=T )
ssr.w    <- ssr
ssr.w[ ssr.w > top    ] <- top
ssr.w[ ssr.w < bottom ] <- bottom
ssr.n <- scale( ssr.w )
ssr.p <- dplyr::ntile( ssr, 100 )
SSR <- data.frame( ssr, ssr.w, ssr.n, ssr.p )
print( summary( SSR ) )
par( mfrow=c(2,2) )
plot( density(ssr,   na.rm=T), main="Self Sufficiency Ratio (SSR)" )
plot( density(ssr.w, na.rm=T), main="SSR Winsorized" )
plot( density(ssr.n, na.rm=T), main="SSR Standardized as Z" )
plot( density(ssr.p, na.rm=T), main="SSR as Percentile" )
df.ssr <- data.frame( cbind( df, SSR ) )
return( df.ssr )
}
d <- get_ssr( df = dat, prog.serv.rev = 'x1', total.expense = 'x2' )
d <- get_ssr( df = dat, prog.serv.rev = c('x1'), total.expense = c('x2' ) )
x3 <- rnorm( 1000,100,30 )
x4 <- rnorm( 1000,200,30 )
x3[ seq( from = 1, to = 1000, 50 ) ] <- NA
x4[ seq( from = 1, to = 1000, 71 ) ] <- NA
dat_01 <- data.frame( x1, x2, x3, x4 )
colnames( dat_01 ) <- c( 'F9_08_REV_PROG_TOT_TOT', 'F9_09_EXP_TOT_TOT',
'F9_01_REV_PROG_TOT_CY', 'F9_01_EXP_TOT_CY')
d <- get_ssr( dat_01) # not working
install.packages("rlang")
library(rlang)
install.packages('installr')
library(installr)
updateR()
installr()
updateR
updateR()
shiny::runApp('/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/np-density-dashboard/R/Nonprofit-Density')
runApp()
runApp('/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/np-density-dashboard/R/Nonprofit-Density')
runApp('/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/np-density-dashboard/R/Nonprofit-Density')
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
