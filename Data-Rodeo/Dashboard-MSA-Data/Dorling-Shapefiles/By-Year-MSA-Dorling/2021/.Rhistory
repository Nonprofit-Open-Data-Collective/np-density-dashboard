distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# this dataset should have same number of rows as d.1 (all census tracts) and no missings
# in any of the columns
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
# now loop and make store shapefiles as .rds in "/Data-Rodeo"
# dir.create( "Dorling-Shapefiles" ) # create subfolder to store Dorling Cartogram sf objects
# dir()
# create LOG file/metadata
log.head <- c( "Iteration", "MSA", "No.Tracts", "Pop", "No.NPO"," Save.Time" )
write( log.head, file = "MSA-Data-Log.txt", append = F, sep = "\t" )
d.3 <- st_transform( d.3, crs = 3395 ) # ensure data are in compatible projection before using cartogram fct
### NOTE: The following loop may take quite a while to run depending on your machine's specifications ###
# loop
for ( j in 1:length( msa.file ) ) {
start.time <- Sys.time()
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[j] )  )
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[j], ".rds" ))
## Dorling Cartogram transformation and save in subfolder
setwd( paste0( "../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
d.dorling <- cartogram_dorling( x = dat, weight = "pop.w" , k = 0.05 ) # projects to Dorling Cartogram
saveRDS( d.dorling , paste0( msa.file[j], "-Dorling", c(2014:2021)[j], ".rds" ))
setwd( ".." ) # back up to parent dir
end.time <- Sys.time()
# update log/metadata
Iteration <- i
MSA <- as.character( levels( factor( dat$MSA ) )[1] )
No.Tracts <- as.character( nrow( dat ) )
Pop <- as.character( sum( dat$pop, na.rm = T ) )
No.NPO <- as.character( sum( dat$n, na.rm = T ) )
Save.Time <- as.character( end.time - start.time )
log <- c( Iteration, MSA, No.Tracts, Pop, No.NPO, Save.Time)
log <- paste( log, collapse = "\t" )
write( log, file = "MSA-Data-Log.txt", append = T, sep = "\t" )
print( end.time - start.time)
print( paste0( "Iteration ", i, "/", length( msa.file ), " complete" ) )
}
}
i=1
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
library( tidyverse )
library( urbnmapr )         # state/county shapefiles
library( sf )               # simple features framework
library( tigris )           # TIGER shapefiles
library( tidycensus )       # Census data queries
library( cartogram )        # Create sf objects for Dorling Cartograms
options( tigris_class = "sf" )
options( tigris_use_cache = TRUE )
source('/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/np-density-dashboard/R/helpers.R')
lf <- "/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/Large-Files-Bank"
setwd( lf )
# data containing NPO coordinates as points
npo <- readRDS( 'NONPROFITS-2014-2021v7.rds' )
# convert lat/long to a sf
npo.sf <- npo %>%
filter( is.na( lat ) == F ) %>% # st_as_sf does not allow missing values in coordinate columns; n = 167 missing
st_as_sf( coords = c( "lon", "lat" ), crs = 3395 ) # change projection accordingly
# pull tract-level shapefiles from `tigris`
t <- tracts( cb = TRUE ) # USA Census tract shapefiles
t <- st_transform( t, crs = 3395 ) # project onto compatible crs
# pull Census population (at the tract level) data using `tidycensus`
# merge with NPO dataset and count numbers of NPOs within tracts to create density metric
# loop through state codes as requesting all states at once will cause crash
state.codes <- unique( str_sub( t$GEOID, -11, -10 ) )
# remove FIPS codes for Mariana Islands, American Samoa, Guam, Virgin Islands (`tidycensus` won't return data for these)
state.codes <- state.codes[ !state.codes %in% c( "69", "60", "66", "78" ) ]
# loop through state FIPS codes
l <- list( )
for ( i in 1:length( state.codes ) ) {
start.time <- Sys.time()
l[[i]] <- get_acs( geography = "tract",
variables = c( pop = "B01003_001", pov = "B17001_002", med.income = "B19013_001",
female = "B01001_026", male = "B01001_002" ),
state = state.codes[i]  ) %>%   # This includes all states that we specify in the loop
pivot_wider( id_cols = GEOID, names_from = variable, values_from = estimate ) %>%   # Pivot data since tidycensus returns data table as a long data frame
mutate( poverty.rate = ( pov / pop )*100,
perc.female = ( female / pop )*100,
perc.male = ( male / pop )*100 ) %>%
select( GEOID, pop, poverty.rate, med.income, perc.female, perc.male )
end.time <- Sys.time()
print( end.time - start.time)
print( paste0( "Iteration ", i, "/", length( state.codes ), " complete" ) )
}
d.1 <- do.call( "rbind", l ) # dataframe containing a column for tract GEOID and a column for its total population
# this dataset should contain some ~85,000 observations as it contains all census tracts in the US
d.2 <- npo.sf %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# obtain MSA cartographic boundary shapefiles
m <- core_based_statistical_areas( cb = T )
m <- st_transform( m, crs = 3395 )             # compatible crs
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
keep.msa.1.5m <- sj %>%
group_by( MSA ) %>%
mutate( sum.pop = sum( pop )) %>%
ungroup() %>%
filter( sum.pop > 1500000 ) %>%
distinct( MSA )
d.3 <- sj %>%
filter( MSA %in% keep.msa.1.5m$MSA )
msas <- unique( d.3$MSA ) # dataset names will be according to MSA names
# text process them a bit to make them easier to store
msa.file <- msas %>%
str_extract( ., "^.*(?=(\\,))" ) %>%   # first, extract everything before the comma (subsequently leading to the state)
str_replace( ., "\\s", "-" )%>%        # replace white space with a "-"
str_remove( ., "\\." ) %>%             # remove any "." from the strings
str_replace( ., "\\s", "-" )           # run again because we still have some white spaces that have not been replaced
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
yr.levels <- levels( factor( npo$YR ) )
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
d.3 <- st_transform( d.3, crs = 3395 ) # ensure data are in compatible projection before using cartogram fct
# loop
for ( j in 1:length( msa.file ) ) {
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[j] )  )
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[j], ".rds" ))
## Dorling Cartogram transformation and save in subfolder
setwd( paste0( "../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
d.dorling <- cartogram_dorling( x = dat, weight = "pop.w" , k = 0.05 ) # projects to Dorling Cartogram
saveRDS( d.dorling , paste0( msa.file[j], "-Dorling", c(2014:2021)[j], ".rds" ))
}
j=1
msa.file
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
dat
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[j] )  )
getwd()
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[j], ".rds" ))
setwd( paste0( "../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
setwd( paste0( "../../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
getwd()
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
nrow(dat)
paste0( "Nested iteration ", paste0( i,".",j ), "/", length( msa.file ), " complete" )
paste0( "Nested iteration ", paste0( i,": ",j ), "/", length( msa.file ), " complete" )
i
# loop
for ( j in 1:length( msa.file ) ) {
start.time.nested <- Sys.time()
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[j] )  )
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[j], ".rds" ))
## Dorling Cartogram transformation and save in subfolder
setwd( paste0( "../../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
d.dorling <- cartogram_dorling( x = dat, weight = "pop.w" , k = 0.05 ) # projects to Dorling Cartogram
saveRDS( d.dorling , paste0( msa.file[j], "-Dorling", c(2014:2021)[j], ".rds" ))
end.time <- Sys.time()
print( end.time.nested - start.time.nested )
print( paste0( "Nested iteration ", paste0( i,": ",j ), "/", length( msa.file ), " complete" ) )
}
for ( i in 1:length( yr.levels ) ) {
start.time <- Sys.time()
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# this dataset should have same number of rows as d.1 (all census tracts) and no missings
# in any of the columns
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
# now loop and make store shapefiles as .rds in "/Data-Rodeo"
d.3 <- st_transform( d.3, crs = 3395 ) # ensure data are in compatible projection before using cartogram fct
### NOTE: The following loop may take quite a while to run depending on your machine's specifications ###
# loop
for ( j in 1:length( msa.file ) ) {
start.time.nested <- Sys.time()
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[j] )  )
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[j], ".rds" ))
## Dorling Cartogram transformation and save in subfolder
setwd( paste0( "../../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
d.dorling <- cartogram_dorling( x = dat, weight = "pop.w" , k = 0.05 ) # projects to Dorling Cartogram
saveRDS( d.dorling , paste0( msa.file[j], "-Dorling", c(2014:2021)[j], ".rds" ))
end.time <- Sys.time()
print( end.time.nested - start.time.nested )
print( paste0( "Nested iteration ", paste0( i,": ",j ), "/", length( msa.file ), " complete" ) )
}
end.time <- Sys.time()
print( end.time - start.time)
print( paste0( "Iteration ", i, "/", length( msa.file ), " complete" ) )
}
for ( i in 1:length( yr.levels ) ) {
start.time <- Sys.time()
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# this dataset should have same number of rows as d.1 (all census tracts) and no missings
# in any of the columns
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
# now loop and make store shapefiles as .rds in "/Data-Rodeo"
d.3 <- st_transform( d.3, crs = 3395 ) # ensure data are in compatible projection before using cartogram fct
### NOTE: The following loop may take quite a while to run depending on your machine's specifications ###
# loop
for ( j in 1:length( msa.file ) ) {
start.time.nested <- Sys.time()
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[j] )  )
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[j], ".rds" ))
## Dorling Cartogram transformation and save in subfolder
setwd( paste0( "../../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[j] ) ) # save sf projection for Dorling Cartogram in a subfolder
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
d.dorling <- cartogram_dorling( x = dat, weight = "pop.w" , k = 0.05 ) # projects to Dorling Cartogram
saveRDS( d.dorling , paste0( msa.file[j], "-Dorling", c(2014:2021)[j], ".rds" ))
end.time.nested <- Sys.time()
print( end.time.nested - start.time.nested )
print( paste0( "Nested iteration ", paste0( i,": ",j ), "/", length( msa.file ), " complete" ) )
}
end.time <- Sys.time()
print( end.time - start.time)
print( paste0( "Iteration ", i, "/", length( msa.file ), " complete" ) )
}
i=1
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
setwd( lf )
setwd("../np-density-dashboard/Data-Rodeo/Dashboard-County-Data/Dorling-Shapefiles")
# dir.create( "Dorling-By-Year" )
setwd( "Dorling-By-Year" )
for( i in 1:length( yr.levels ) ) {
start.time <- Sys.time()
# no. of NPOs by county 5-digit FIPS in the NPO dataset
n.ct <- npo %>%
filter( YR == yr.levels[i] ) %>%                       # filter by year
group_by( fips.ct ) %>%
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>% # count of NPO's within county FIPS
distinct( fips.ct, n, YR )
# no. of rows in this data should reflect the number of counties for which we have data for
# i.e., less than 3142 counties in the USA since there weren't filers in every county
# merge ACS data to NPO data where rows are counties identified by their 5-digit FIPS codes
dat.yr <-  left_join( ct.sf.tigris, n.ct, by = c( "GEOID" = 'fips.ct') ) %>% # join count data to `tigris` shapefile
rename( fips.ct = GEOID ) %>%             # rename identifier
left_join(., pop.ct, by='fips.ct') %>%    # join to Census data
mutate( n = ifelse( is.na( n )==T, 0, n ) ) %>%     # if a county has NA in its count of NPOs, it is because it was not present in the 1023-EZ data for that given year, meaning there were no filers in that county...thus, zero NPOs
mutate( dens = ( n / pop ) * 1000 ) %>%           # calculate density metric
mutate( pop.w = pop /  max( pop.ct$pop, na.rm=T ) ) %>%   # standardizes it
st_transform( crs = 3395 ) %>%
filter( is.na( pop.w )==F )  # remove FIPS in Guam, VI, and some Alaska counties without population estimates
# `cartogram_dorling` function will break if there are missing values in the weight parameter.
# no. of rows in this dataset should be ~3234 (one for each county in the US)
yr.dorling <- cartogram_dorling( x = dat.yr, weight = "pop.w" , k = 0.8 )  # k parameter was increased to augment circle size
saveRDS( yr.dorling, paste0("USA-Counties-Dorling-", c( 2014:2021 )[i],".rds" ) )
end.time <- Sys.time()
print( end.time - start.time)
print( paste0( "Iteration ", i, "/", length( yr.levels ), " complete" ) )
}
for ( i in 1:length( yr.levels ) ) {
start.time <- Sys.time()
d.2 <- npo.sf %>%
filter( YR == yr.levels[i]) %>%
group_by( GEOID ) %>%         # group by tract FIPS for subsequent computation
mutate( n = ifelse( is.na( n() ) ==T, 0, n( ) ) ) %>%         # count number of rows per tract FIPS since rows are the nonprofits
ungroup() %>%
distinct( GEOID, n ) %>%      # retain only a dataframe of tract FIPS and the no. of nonprofits in them
left_join( d.1, .) %>%        # join with Census population data
mutate( n = ifelse( is.na( n ), 0, n ),                # tracts that have an NA (i.e., tracts not represented in the NCCS data) get allocated 0 new NPOs
dens = ( n / pop ) * 1000 ,                    # create NPO density metric (NPOs per 1k in the population)
dens = ifelse( is.na( dens ), 0, dens ) ) %>%  # those still having a "NA" for the density metric are tracts that have 0 population and 0 number of nonprofits (n = 763 instances of 0/0)
distinct( GEOID, pop, poverty.rate, med.income,
perc.female, perc.male, n, dens )                # keep unique rows (i.e., 1 for each tract)
# this dataset should have same number of rows as d.1 (all census tracts) and no missings
# in any of the columns
# spatial join MSA names to tract-level data
sj <- m %>%
rename (MSA = NAME ) %>%
select( MSA, geometry ) %>%
st_join( t, ., left = T ) %>%          # spatial left join
left_join( ., d.2) %>%                 # append Census data
distinct( )
# now loop and make store shapefiles as .rds in "/Data-Rodeo"
d.3 <- st_transform( d.3, crs = 3395 ) # ensure data are in compatible projection before using cartogram fct
### NOTE: The following loop may take quite a while to run depending on your machine's specifications ###
# loop
for ( j in 1:length( msa.file ) ) {
start.time.nested <- Sys.time()
# subset by MSA
dat <- d.3[ which( d.3$MSA == msas[j] ), ]
# do a spatial intersection to ensure Census tracts touching but outside the boundaries are excluded
sub.area <- filter( m, grepl( msas[j], NAME ) ) # obtain cartographic boundary geometries
s <- st_within( dat, sub.area ) # spatial overlay
these <- map_lgl( s, function( x ) {        # logical for rows to keep
if ( length( x ) == 1 ) {
return( TRUE )
} else {
return( FALSE )
}
} )
# final subset to remove boundary Census tracts outside MSA
dat <- dat[ these, ]
# save in parent dir
setwd( lf )
setwd( paste0( "../np-density-dashboard/Data-Rodeo/Dashboard-MSA-Data/By-Year-MSA/", c(2014:2021)[i] )  )
saveRDS( dat , paste0( msa.file[j], "-MSA-", c(2014:2021)[i], ".rds" ))
## Dorling Cartogram transformation and save in subfolder
setwd( paste0( "../../Dorling-Shapefiles/By-Year-MSA-Dorling/", c(2014:2021)[i] ) ) # save sf projection for Dorling Cartogram in a subfolder
dat$pop.w <- dat$pop /  max( dat$pop, na.rm = T )   # standardizes it by max weight
d.dorling <- cartogram_dorling( x = dat, weight = "pop.w" , k = 0.05 ) # projects to Dorling Cartogram
saveRDS( d.dorling , paste0( msa.file[j], "-Dorling-", c(2014:2021)[i], ".rds" ))
end.time.nested <- Sys.time()
print( end.time.nested - start.time.nested )
print( paste0( "Nested iteration ", paste0( i,": ",j ), "/", length( msa.file ), " complete" ) )
}
end.time <- Sys.time()
print( end.time - start.time)
print( paste0( "Iteration ", i, "/", length( msa.file ), " complete" ) )
}
