library( dplyr )
library( tidyr )
library( pander )
library( httr )
library( ggmap )
library( tidyverse )
library( tidygeocoder ) # for geocoding addresses using Census API, Google API, etc.
wd<- ( '/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/np-density-dashboard/Data-Wrangled' )
setwd( wd )
# read in ppl data
setwd( wd )
ppl <- readRDS( "pplAddresses_census.rds" )
# setting wd
wd2 <- '/Volumes/My Passport for Mac/Urban Institute/Summer Projects/Geospatial Dashboard/np-density-dashboard/addresses_ppl'
setwd( wd2 )
# Selecting only essential variables
ppl <- dplyr::select( ppl, ID, Address, City, State, Zip )
# setting wd
setwd( wd2 )
loops
# Spliting address files into files with 500 addresses each
loops <- ceiling( nrow( ppl ) / 500 ) # ceiling function rounds up an integer. so loops has the amount of 500s that fit rounded up.
loops
# setting wd
setwd( wd2 )
for ( i in 1:loops ){
start_time <- Sys.time( )# document start times
res<- tibble( read.csv( paste0( "Addressppl", i, ".csv" ) ) )%>%
geocode( ., street = Address, city = City, state = State, postalcode = Zip, method = 'census', full_results = T )
write.csv( res, paste0( "Results/Resultsppl", i, ".csv" ), row.names = F )
end_time <- Sys.time( )# document start times
print( paste0( "Iteration #", i, " complete" ) ) # print iteration to keep track of loop
print( end_time - start_time ) # print system time to keep track of iteration progress
}
